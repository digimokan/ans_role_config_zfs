#!/bin/sh
# vim: set filetype=sh:

################################################################################
# Purpose:   Provide helper script for working with ZFS pools and datasets
# Args/Opts: See usage (run with -h option).
# Meta:      Script installed by ansible {{ role_name | basename }}.
# Style:     ENV_VAR, GLOBAL_VAR, GLOBAL_READONLY_VAR, func_local_var, my_func
# Refs:      https://docs.freebsd.org/en/books/handbook/zfs/
#            https://docs.freebsd.org/en/books/handbook/disks/
################################################################################

# GLOBAL VARS:

# Constants
PROG_NAME="$(basename "${0}")"
readonly PROG_NAME
DEFAULT_POOL='{{ cfg_zfs_default_pool }}'
readonly DEFAULT_POOL
DEFAULT_MOUNT_POINT_BASE="/mnt"
readonly DEFAULT_MOUNT_POINT_BASE

# Mutable User Normal Cmd Option Selections
PRINT_HELP_MENU='false'
LIST_POOLS_STATUS='false'
CREATE_STORAGE_POOL='false'
DETACH_DEVICE_FROM_POOL='false'
ATTACH_NEW_DISK_TO_ROOT_MIRROR='false'
ATTACH_NEW_DISK_TO_STORAGE_MIRROR='false'
ADD_READ_CACHE_DISK_TO_POOL='false'
SCRUB_POOL_DATA='false'

# Mutable User Contingency Cmd Option Selections
ATTACH_ZFS_PART_TO_ROOT_MIRROR='false'
OFFLINE_DEVICE_FROM_POOL='false'
ONLINE_DEVICE_INTO_POOL='false'

# Mutable User Options
ZFS_DEVICE_PATH=""
ZFS_PART_DEVICE_PATH=""
ZFS_DISK_DEVICE_PATH=""
WHOLE_DISK_PATH=""
ZFS_PART_PATH=""
MOUNT_POINT=""
ENCRYPTION_PASSWORD=""
POOL="${DEFAULT_POOL}"

# LOCAL FUNCTIONS:

print_usage() {
  prog_name_num_chars="$(printf "%s" "${PROG_NAME}" | wc -m)"
  leading_indent=''
  i=0
  while [ "${i}" -lt "${prog_name_num_chars}" ]; do
    leading_indent="${leading_indent} "
    i=$((i + 1))
  done

  mountpt="${DEFAULT_MOUNT_POINT_BASE}/[pool-name]"

  printf "NORMAL USAGE:\n"
  printf "  %s  -h\n" "${PROG_NAME}"
  printf "  %s  -l\n" "${PROG_NAME}"
  printf "  %s  -c|--create-storage-pool                -K <path_to_disk>                       [-M <path>]   -P <pool_name>\n" "${PROG_NAME}"
  printf "  %s  -d|--detach-device-from-pool                               -C <path_to_device>               [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -r|--attach-new-disk-to-root-mirror     -K <path_to_disk>  -R <path_to_device>  [-E <pswd>]  [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -s|--attach-new-disk-to-storage-mirror  -K <path_to_disk>  -S <path_to_device>               [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -y|--add-read-cache-disk-to-pool        -K <path_to_disk>                                    [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -u|--scrub-pool-data                                                                         [-P <pool_name>]\n" "${PROG_NAME}"
  printf "CONTINGENCY USAGE:\n"
  printf "  %s  -x|--offline-device-from-pool                              -C <path_to_device>               [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -j|--attach-zfs-part-to-root-mirror     -T <path_to_part>  -R <path_to_device>               [-P <pool_name>]\n" "${PROG_NAME}"
  printf "  %s  -n|--online-device-into-pool                               -C <path_to_device>               [-P <pool_name>]\n" "${PROG_NAME}"
  printf "OPTIONS:\n"
  printf "  -h, --help\n"
  printf "      print this help message\n"
  printf "  -l, --list-pools-status\n"
  printf "      list status of all pools, along with their vdevs and devices\n"
  printf "  -c, --create-storage-pool\n"
  printf "      create a new storage pool from a new whole disk\n"
  printf "  -d, --detach-device-from-pool\n"
  printf "      remove a (possibly bad) device from a pool (offlines + detaches device)\n"
  printf "  -r, --attach-new-disk-to-root-mirror\n"
  printf "      format, partition, and attach a new disk to a device in a root pool, creating a mirror-vdev\n"
  printf "  -s, --attach-new-disk-to-storage-mirror\n"
  printf "      attach a new disk to a device in a storage pool, creating a mirror-vdev\n"
  printf "  -y, --add-read-cache-disk-to-pool\n"
  printf "      add a new disk to the pool as a Level 2 Adjustable Replacement Cache (do not mirror)\n"
  printf "  -u, --scrub-pool-data\n"
  printf "      read all data in pool (verifying data checksums), and repair as required\n"
  printf "  -x, --offline-device-from-pool\n"
  printf "      offline a device, without detaching it from a pool\n"
  printf "  -j, --attach-zfs-part-to-root-mirror\n"
  printf "      attach a disk's existing zfs partition to a device in a root pool, creating a mirror-vdev\n"
  printf "  -n --online-device-into-pool\n"
  printf "      online an offline device, making it an active part of a pool\n"
  printf "  -C <path_to_device>, --zfs-device=<path_to_device>\n"
  printf "      any kind of zfs device in a vdev (whole disk, partition, etc)\n"
  printf "  -R <path_to_device>, --zfs-part-device=<path_to_device>\n"
  printf "      a disk partition, that is a zfs device in a vdev\n"
  printf "  -S <path_to_device>, --zfs-disk-device=<path_to_device>\n"
  printf "      a whole disk, that is a zfs device in a vdev\n"
  printf "  -K <path_to_disk>, --whole-disk=<path_to_disk>\n"
  printf "      a path to a whole disk, that is NOT an active zfs device in a vdev\n"
  printf "  -T <path_to_part>, --zfs-part=<path_to_part>\n"
  printf "      a path to a zfs disk partition, that is NOT an active zfs device in a vdev\n"
  printf "  -M <path>, --mount-point=<path>\n"
  printf "      path to mount point (default: %s)\n" "${mountpt}"
  printf "  -E <pswd>, --encryption-password=<pswd>\n"
  printf "      a password for GELI-encrypting the whole disk\n"
  printf "  -P <pool_name>, --pool=<pool_name>\n"
  printf "      specify pool to query status or operate on (default: %s)\n" "${DEFAULT_POOL}"
  printf "EXIT CODES:\n"
  printf "    0  ok\n"
  printf "    1  one or more devices in a pool's vdev is not online\n"
  printf "    5  zfs status/list error\n"
  printf "   10  zfs device detach error\n"
  printf "   20  disk format or partition error\n"
  printf "   60  zfs device online/attach/add error\n"
  printf "   80  zfs pool create error\n"
  printf "  100  zfs pool scrub error\n"
  printf "  128  usage or options error\n"
}

get_cmd_opts() {
  while getopts ':hlcdrsyuxjnC:R:S:K:T:M:E:P:-:' option; do
    short_opt_arg="${OPTARG}"
    case "${option}" in
      h)  handle_print_help_menu ;;
      l)  handle_list_pools_status ;;
      c)  handle_create_storage_pool ;;
      d)  handle_detach_device_from_pool ;;
      r)  handle_attach_new_disk_to_root_mirror ;;
      s)  handle_attach_new_disk_to_storage_mirror ;;
      y)  handle_add_read_cache_disk_to_pool ;;
      u)  handle_scrub_pool_data ;;
      x)  handle_offline_device_from_pool ;;
      j)  handle_attach_zfs_part_to_root_mirror ;;
      n)  handle_online_device_into_pool ;;
      C)  handle_zfs_device "${short_opt_arg}" ;;
      R)  handle_zfs_part_device "${short_opt_arg}" ;;
      S)  handle_zfs_disk_device "${short_opt_arg}" ;;
      K)  handle_whole_disk "${short_opt_arg}" ;;
      T)  handle_zfs_part "${short_opt_arg}" ;;
      M)  handle_mount_point "${short_opt_arg}" ;;
      E)  handle_encryption_password "${short_opt_arg}" ;;
      P)  handle_pool "${short_opt_arg}" ;;
      -)  long_opt_name="${OPTARG}"
          long_opt_arg="${OPTARG#*=}"
          case ${long_opt_name} in
            help)                                   handle_print_help_menu ;;
            help=*)                                 handle_illegal_long_option_arg "${long_opt_name}" ;;
            list-pools-status)                      handle_list_pools_status ;;
            list-pools-status=*)                    handle_illegal_long_option_arg "${long_opt_name}" ;;
            create-storage-pool)                    handle_create_storage_pool ;;
            create-storage-pool=*)                  handle_illegal_long_option_arg "${long_opt_name}" ;;
            detach-device-from-pool)                handle_detach_device_from_pool ;;
            detach-device-from-pool=*)              handle_illegal_long_option_arg "${long_opt_name}" ;;
            attach-new-disk-to-root-mirror)         handle_attach_new_disk_to_root_mirror ;;
            attach-new-disk-to-root-mirror=*)       handle_illegal_long_option_arg "${long_opt_name}" ;;
            attach-new-disk-to-storage-mirror)      handle_attach_new_disk_to_storage_mirror ;;
            attach-new-disk-to-storage-mirror=*)    handle_illegal_long_option_arg "${long_opt_name}" ;;
            add-read-cache-disk-to-pool)            handle_add_read_cache_disk_to_pool ;;
            add-read-cache-disk-to-pool=*)          handle_illegal_long_option_arg "${long_opt_name}" ;;
            scrub-pool-data)                        handle_scrub_pool_data ;;
            scrub-pool-data=*)                      handle_illegal_long_option_arg "${long_opt_name}" ;;
            offline-device-from-pool)               handle_offline_device_from_pool ;;
            offline-device-from-pool=*)             handle_illegal_long_option_arg "${long_opt_name}" ;;
            attach-zfs-part-to-root-mirror)         handle_attach_zfs_part_to_root_mirror ;;
            attach-zfs-part-to-root-mirror=*)       handle_illegal_long_option_arg "${long_opt_name}" ;;
            online-device-into-pool)                handle_online_device_into_pool ;;
            online-device-into-pool=*)              handle_illegal_long_option_arg "${long_opt_name}" ;;
            zfs-device=?*)                          handle_zfs_device "${long_opt_arg}" ;;
            zfs-device*)                            handle_missing_long_option_arg "${long_opt_name}" ;;
            zfs-part-device=?*)                     handle_zfs_part_device "${long_opt_arg}" ;;
            zfs-part-device*)                       handle_missing_long_option_arg "${long_opt_name}" ;;
            zfs-disk-device=?*)                     handle_zfs_disk_device "${long_opt_arg}" ;;
            zfs-disk-device*)                       handle_missing_long_option_arg "${long_opt_name}" ;;
            whole-disk=?*)                          handle_whole_disk "${long_opt_arg}" ;;
            whole-disk*)                            handle_missing_long_option_arg "${long_opt_name}" ;;
            zfs-part=?*)                            handle_zfs_part "${long_opt_arg}" ;;
            zfs-part*)                              handle_missing_long_option_arg "${long_opt_name}" ;;
            mount-point=?*)                         handle_mount_point "${long_opt_arg}" ;;
            mount-point*)                           handle_missing_long_option_arg "${long_opt_name}" ;;
            encryption-password=?*)                 handle_encryption_password "${long_opt_arg}" ;;
            encryption-password*)                   handle_missing_long_option_arg "${long_opt_name}" ;;
            pool=?*)                                handle_pool "${long_opt_arg}" ;;
            pool*)                                  handle_missing_long_option_arg "${long_opt_name}" ;;
            '')                                     break ;; # non-option arg starting with '-'
            *)                                      handle_unknown_option "${long_opt_name}" ;;
          esac ;;
      \?) handle_unknown_option "${short_opt_arg}" ;;
    esac
  done
}

exit_with_cleanup() {
  err_code="${1}"
  exit "${err_code}"
}

print_err_msg() {
  err_msg="${1}"
  printf "ERROR:\n%s: %s\n" "${PROG_NAME}" "${err_msg}"
}

quit_with_err_msg() {
  err_msg="${1}"
  err_code="${2}"
  print_err_msg "${err_msg}"
  exit_with_cleanup "${err_code}"
}

quit_if_rc_not_zero() {
  cmd_exit_code="${1}"
  err_msg="${2}"
  script_exit_code="${3}"
  if [ "${cmd_exit_code}" != 0  ]; then
    quit_with_err_msg "${err_msg}" "${script_exit_code}"
  fi
}

try_silent_with_exit() {
  cmd="${1}"
  err_msg="${2}"
  err_code="${3}"

  eval "${cmd}"
  exit_code="${?}"
  if [ "${exit_code}" != 0 ]; then
    quit_with_err_msg "${err_msg}" "${err_code}"
  fi
}

try_silent_print_with_exit() {
  cmd="${1}"
  op_descrip="${2}"
  err_code="${3}"

  printf "Now %s with \"%s\"...\n" "${op_descrip}" "${cmd}"
  err_msg="error ${op_descrip}"
  try_silent_with_exit \
    "${cmd}" \
    "${err_msg}" "${err_code}"
}

try_total_silent_with_exit() {
  cmd="${1}"
  op_descrip="${2}"

  printf "Now %s with \"%s\"...\n" "${op_descrip}" "${cmd}"
  eval "${cmd}" 1> /dev/null 2>&1
}

handle_unknown_option() {
  short_opt_letter_or_long_opt_name="${1}"
  err_msg="unknown option \"${short_opt_letter_or_long_opt_name}\""
  quit_with_err_msg "${err_msg}" 5
}

handle_illegal_long_option_arg() {
  long_opt_name="${1}"
  err_msg="illegal argument in \"${long_opt_name}\""
  quit_with_err_msg "${err_msg}" 5
}

handle_missing_long_option_arg() {
  long_opt_name="${1}"
  err_msg="missing argument for option \"${long_opt_name}\""
  quit_with_err_msg "${err_msg}" 5
}

handle_print_help_menu() {
  if [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_ZFS_PART_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 5
  fi
  PRINT_HELP_MENU='true'
}

handle_list_pools_status() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_ZFS_PART_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 5
  fi
  LIST_POOLS_STATUS='true'
}

handle_create_storage_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_ZFS_PART_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 5
  fi
  CREATE_STORAGE_POOL='true'
}

handle_detach_device_from_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_ZFS_PART_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 5
  fi
  DETACH_DEVICE_FROM_POOL='true'
}

handle_attach_new_disk_to_root_mirror() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_ZFS_PART_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 5
  fi
  ATTACH_NEW_DISK_TO_ROOT_MIRROR='true'
}

handle_attach_new_disk_to_storage_mirror() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_ZFS_PART_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 5
  fi
  ATTACH_NEW_DISK_TO_STORAGE_MIRROR='true'
}

handle_add_read_cache_disk_to_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_ZFS_PART_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 5
  fi
  ADD_READ_CACHE_DISK_TO_POOL='true'
}

handle_scrub_pool_data() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_ZFS_PART_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 5
  fi
  SCRUB_POOL_DATA='true'
}

handle_offline_device_from_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${ATTACH_ZFS_PART_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 5
  fi
  OFFLINE_DEVICE_FROM_POOL='true'
}

handle_attach_zfs_part_to_root_mirror() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 5
  fi
  ATTACH_ZFS_PART_TO_ROOT_MIRROR='true'
}

handle_online_device_into_pool() {
  if [ "${PRINT_HELP_MENU}" = 'true' ] || \
     [ "${LIST_POOLS_STATUS}" = 'true' ] || \
     [ "${CREATE_STORAGE_POOL}" = 'true' ] || \
     [ "${DETACH_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_ROOT_MIRROR}" = 'true' ] || \
     [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ] || \
     [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ] || \
     [ "${SCRUB_POOL_DATA}" = 'true' ] || \
     [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ] || \
     [ "${ATTACH_ZFS_PART_TO_ROOT_MIRROR}" = 'true' ]; then
    quit_with_err_msg "mutually exclusive options selected" 5
  fi
  ONLINE_DEVICE_INTO_POOL='true'
}

handle_zfs_device() {
  ZFS_DEVICE_PATH="${1}"
}

handle_zfs_part_device() {
  ZFS_PART_DEVICE_PATH="${1}"
}

handle_zfs_disk_device() {
  ZFS_DISK_DEVICE_PATH="${1}"
}

handle_whole_disk() {
  WHOLE_DISK_PATH="${1}"
}

handle_zfs_part() {
  ZFS_PART_PATH="${1}"
}

handle_mount_point() {
  MOUNT_POINT="${1}"
}

handle_encryption_password() {
  ENCRYPTION_PASSWORD="${1}"
}

handle_pool() {
  POOL="${1}"
}

validate_whole_disk_name_or_path() {
  whole_disk_name_or_path="${1}"

  try_silent_with_exit \
    "camcontrol identify ${whole_disk_name_or_path} 1> /dev/null 2>&1" \
    "${whole_disk_name_or_path} must be a valid whole disk" 128
}

validate_string_is_unsigned_integer() {
  str="${1}"

  try_silent_with_exit \
    "test ! -z ${str}" \
    "${str} must not be an empty string" 128
  try_silent_with_exit \
    "test \"${str}\" -eq \"${str}\"" \
    "${str} must be an unsigned integer" 128
}

validate_partition_without_extension() {
  # Note: this basename must not have a file extension
  partition_basename="${1}"

  try_silent_with_exit \
    "geom part status -s | tr -s ' ' | cut -d' ' -f1 | grep ${partition_basename} 1> /dev/null 2>&1" \
    "\"${partition_basename}\" must be a valid partition" 128
}

validate_active_device_in_vdev() {
  device="${1}"

  try_silent_with_exit \
    "zpool list -v -P | grep --regexp=\"\s${device}\s\" 1> /dev/null" \
    "${device} must be an active zfs device in a vdev" 128
}

validate_not_active_device_in_vdev() {
  device="${1}"

  try_silent_with_exit \
    "! zpool list -v -P | grep ${device}" \
    "${device} must not be an active zfs device in a vdev" 128
}

validate_item_is_full_disk() {
  item="${1}"

  try_silent_with_exit \
    "camcontrol identify ${item} 1> /dev/null 2>&1" \
    "${item} must be a full disk, not a disk partition" 128
}

validate_item_is_not_full_disk() {
  item="${1}"

  try_silent_with_exit \
    "! camcontrol identify ${item} 1> /dev/null 2>&1" \
    "${item} must be a partition, not a path to a full disk" 128
}

validate_file_has_extension() {
  filename_or_file_path="${1}"
  file_extension="${2}"
  err_msg="${3}"

  try_silent_with_exit \
    "test \"${filename_or_file_path##*.}\" = \"${file_extension}\"" \
    "${err_msg}" 128
}

validate_file_has_no_extension() {
  filename_or_file_path="${1}"
  err_msg="${2}"

  filename_or_file_path_ext_removed="${filename_or_file_path%.*}"
  try_silent_with_exit \
    "test \"${filename_or_file_path_ext_removed}\" = \"${filename_or_file_path}\"" \
    "${err_msg}" 128
}

validate_zfs_geli_ecrypted_partition() {
  path_to_zfs_geli_enc_part="${1}"
  err_msg="${2}"

  try_silent_with_exit \
    "geli status \"${path_to_zfs_geli_enc_part}\" 1> /dev/null 2>&1" \
    "${err_msg}" 128
}

validate_zfs_or_zfs_geli_partition() {
  path_to_part="${1}"
  err_msg="${2}"

  part_name="$(print_filename_without_extension "${path_to_part}")"

  try_silent_with_exit \
    "gpart show -p | grep ${part_name} | grep zfs 1> /dev/null 2>&1" \
    "${err_msg}" 128
}

check_running_as_root() {
  if [ "$(id -un)" != 'root' ]; then
    quit_with_err_msg "must run this script as root for this operation" 128
  fi
}

check_active_zfs_device_option() {
  if [ "${ZFS_DEVICE_PATH}" = '' ]; then
    quit_with_err_msg "\"--zfs-device\" option must be specified" 128
  fi
  validate_active_device_in_vdev "${ZFS_DEVICE_PATH}"
}

check_zfs_part_device_option() {
  if [ "${ZFS_PART_DEVICE_PATH}" = '' ]; then
    quit_with_err_msg "\"--zfs-part-device\" option must be specified" 128
  fi
  validate_active_device_in_vdev "${ZFS_PART_DEVICE_PATH}"
  validate_item_is_not_full_disk "${ZFS_PART_DEVICE_PATH}"
}

check_zfs_disk_device_option() {
  if [ "${ZFS_DISK_DEVICE_PATH}" = '' ]; then
    quit_with_err_msg "\"--zfs-disk-device\" option must be specified" 128
  fi

  validate_active_device_in_vdev "${ZFS_DISK_DEVICE_PATH}"
  validate_item_is_full_disk "${ZFS_DISK_DEVICE_PATH}"
}

check_whole_disk_option() {
  if [ "${WHOLE_DISK_PATH}" = '' ]; then
    quit_with_err_msg "\"--whole-disk\" option must be specified" 128
  fi
  validate_whole_disk_name_or_path "${WHOLE_DISK_PATH}"
  validate_not_active_device_in_vdev "${WHOLE_DISK_PATH}"
}

check_zfs_part_option() {
  if [ "${ZFS_PART_PATH}" = '' ]; then
    quit_with_err_msg "\"--zfs-part\" option must be specified" 128
  fi

  validate_not_active_device_in_vdev "${ZFS_PART_PATH}"
  validate_zfs_or_zfs_geli_partition \
    "${ZFS_PART_PATH}" \
    "--zfs-part must be a zfs disk partition (optionally, GELI-encrypted)"
}

check_pool_is_root_pool() {
  pool="${1}"

  pool_mounted_on_root_dir="$(zfs get -H -o name mountpoint '/' | awk -F '/' '{print $1}')"
  if [ "${pool}" != "${pool_mounted_on_root_dir}" ]; then
    quit_with_err_msg "pool must be the zfs root/boot pool" 128
  fi
}

check_pool_is_not_root_pool() {
  pool="${1}"

  pool_mounted_on_root_dir="$(zfs get -H -o name mountpoint '/' | awk -F '/' '{print $1}')"
  if [ "${pool}" = "${pool_mounted_on_root_dir}" ]; then
    quit_with_err_msg "pool must be a storage pool, NOT the zfs root/boot pool" 128
  fi
}

check_encrypt_pswd_option_supplied_if_req() {
  if [ "${ENCRYPTION_PASSWORD}" = '' ]; then
    validate_file_has_no_extension \
      "${ZFS_PART_DEVICE_PATH}" \
      "since --encryption-password was not supplied, --zfs-part-device should not have a .eli extension"
  else
    validate_file_has_extension \
      "${ZFS_PART_DEVICE_PATH}" \
      "eli" \
      "since --encryption-password was supplied, --zfs-part-device should have a .eli extension"
    validate_zfs_geli_ecrypted_partition \
      "${ZFS_PART_DEVICE_PATH}" \
      "since --encryption-password was supplied, --zfs-part-device should be a GELI-encrypted partition"
  fi
}

check_encrypt_pswd_option_is_not_specified() {
  if [ "${ENCRYPTION_PASSWORD}" != '' ]; then
    quit_with_err_msg "--encryption-password must not be specified for this operation" 128
  fi
}

print_filename_without_extension() {
  path_to_file="${1}"

  # Note: this handles a filename with or without an extension
  basename -- "${path_to_file}" ".${path_to_file##*.}"
}

print_zfs_partition_number() {
  path_to_whole_disk="${1}"

  # Note: part number should be e.g. "1"
  part_number="$(gpart show "${path_to_whole_disk}" | tr -s ' ' | grep --only-matching --regexp='[0-9] freebsd-zfs' | cut -d' ' -f1)"
  validate_string_is_unsigned_integer "${part_number}"
  printf "%s" "${part_number}"
}

print_path_to_zfs_partition_without_eli_ext() {
  path_to_whole_disk="${1}"

  # Note: part name should be e.g. "ada1p3"
  # Note: find the partition type with the zfs partition code
  part_name="$(gpart show -p "${path_to_whole_disk}" | tr -s ' ' | grep --only-matching --regexp='\w* freebsd-zfs' | cut -d' ' -f1)"
  validate_partition_without_extension "${part_name}"
  printf "%s" "/dev/${part_name}"
}

print_path_to_zfs_geli_ecrypted_partition() {
  path_to_whole_disk="${1}"

  path_to_part_without_geli_ext="$(print_path_to_zfs_partition_without_eli_ext "${path_to_whole_disk}")"

  path_to_zfs_geli_enc_part="${path_to_part_without_geli_ext}.eli"
  validate_zfs_geli_ecrypted_partition \
    "${path_to_zfs_geli_enc_part}" \
    "\"${path_to_zfs_geli_enc_part}\" is not a valid GELI-encrypted partition"
  printf "%s" "${path_to_zfs_geli_enc_part}"
}

print_whole_disk_name() {
  whole_disk_path="${1}"

  whole_disk_name="$(basename "${whole_disk_path}")"
  validate_whole_disk_name_or_path "${whole_disk_name}"
  printf "%s" "${whole_disk_name}"
}

print_whole_disk_path() {
  # Note: this may be partition name, path to partition, with/without extension
  part_name_or_part_path="${1}"

  part_name_without_ext="$(print_filename_without_extension "${part_name_or_part_path}")"
  whole_disk_name="$(geom part status -s | grep "${part_name_without_ext}" | tr -s ' ' | cut -d' ' -f3)"
  path_to_whole_disk="/dev/${whole_disk_name}"
  validate_whole_disk_name_or_path "${path_to_whole_disk}"
  printf "%s" "${path_to_whole_disk}"
}

print_mount_point() {
  mount_point_base="${1}"
  user_specified_mount_point="${2}"
  pool="${3}"

  if [ "${user_specified_mount_point}" = '' ]; then
    printf "%s/%s" "${mount_point_base}" "${pool}"
  else
    printf "%s" "${user_specified_mount_point}"
  fi
}

detach_disk_geli_device_as_required() {
  disk_path="${1}"

  disk_name="$(print_whole_disk_name "${disk_path}")"
  geli_device_name="$(geli status | grep "${disk_name}" | tr -s ' ' | cut -d' ' -f1)"

  if [ "${geli_device_name}" != '' ]; then
    try_silent_print_with_exit \
      "geli detach ${geli_device_name}" \
      "detaching geli device" 20
  fi
}

disable_disk_swap_device_as_required() {
  disk_path="${1}"

  swap_device_path="$(swapctl -l | grep "${disk_path}" | tr -s ' ' | cut -d' ' -f1)"

  if [ "${swap_device_path}" != '' ]; then
    try_silent_print_with_exit \
      "swapoff \"${swap_device_path}\"" \
      "disabling swap device" 20
  fi
}

wipe_new_disk_as_required() {
  new_whole_disk_path="${1}"

  detach_disk_geli_device_as_required "${new_whole_disk_path}"
  disable_disk_swap_device_as_required "${new_whole_disk_path}"

  try_total_silent_with_exit \
    "gpart destroy -F ${new_whole_disk_path}" \
    "attempting to wipe new disk's partition table"
}

format_partitions_on_new_root_mirror_disk() {
  new_whole_disk_path="${1}"
  existing_zfs_part_device_path="${2}"

  try_silent_print_with_exit \
    "gpart create -s gpt ${new_whole_disk_path}" \
    "creating partition table on ${new_whole_disk_path}" 20

  existing_whole_disk="$(print_whole_disk_path "${existing_zfs_part_device_path}")"
  part_table_path="/tmp/existing_part_table.txt"

  try_silent_print_with_exit \
    "gpart backup ${existing_whole_disk} > ${part_table_path}" \
    "copying existing disk's partition-table-format to ${part_table_path}" 20

  try_silent_print_with_exit \
    "gpart restore -F ${new_whole_disk_path} < ${part_table_path}" \
    "writing partition table to new disk" 20
}

set_legacy_bios_bootcode_on_partition_1() {
  # ref: https://wiki.freebsd.org/RootOnZFS/GPTZFSBoot
  whole_disk_path="${1}"

  try_silent_print_with_exit \
    "gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ${whole_disk_path}" \
    "setting legacy BIOS bootcode on new disk partition 1" 20
}

set_efi_bootcode_on_partition_1() {
  # ref: https://wiki.freebsd.org/RootOnZFS/GPTZFSBoot
  whole_disk_path="${1}"

  new_disk_part1="${whole_disk_path}p1"

  try_silent_print_with_exit \
    "newfs_msdos -F 32 -c 1 ${new_disk_part1}" \
    "formatting partition 1 on new disk" 20

  temp_mount="/tmp/part1_efi_mount"

  try_silent_print_with_exit \
    "mkdir -p \"${temp_mount}\"" \
    "creating temp mountpoint" 20

  try_silent_print_with_exit \
    "mount -t msdosfs -o longnames ${new_disk_part1} \"${temp_mount}\"" \
    "mounting new disk partition 1" 20

  efi_boot_dir="${temp_mount}/EFI/BOOT"

  try_silent_print_with_exit \
    "mkdir -p \"${efi_boot_dir}\"" \
    "creating EFI boot dir" 20

  try_silent_print_with_exit \
    "cp -f \"/boot/loader.efi\" \"${efi_boot_dir}/BOOTX64.efi\"" \
    "copying EFI partition content" 20

  try_silent_print_with_exit \
    "umount \"${temp_mount}\"" \
    "unmounting new disk partition 1" 20
}

set_bootcode_on_new_root_mirror_disk() {
  new_whole_disk_path="${1}"

  bios_type="$(sysctl -n machdep.bootmethod)"
  if [ "${bios_type}" = 'BIOS' ]; then
    set_legacy_bios_bootcode_on_partition_1 "${new_whole_disk_path}"
  elif [ "${bios_type}" = 'UEFI' ]; then
    set_efi_bootcode_on_partition_1 "${new_whole_disk_path}"
  else
    quit_with_err_msg "system BIOS type is not \"BIOS\" or \"UEFI\"" 20
  fi
}

geli_encrypt_new_disk_zfs_part_as_req() {
  new_whole_disk_path="${1}"

  if [ "${ENCRYPTION_PASSWORD}" != '' ]; then
    zfs_part_path="$(print_path_to_zfs_partition_without_eli_ext "${new_whole_disk_path}")"
    temp_enc_passwd_file="/tmp/geli_enc_zfs_part_pass.txt"

    try_silent_with_exit \
      "printf \"%s\" ${ENCRYPTION_PASSWORD} > \"${temp_enc_passwd_file}\"" \
      "error writing encryption password into temp file" 20

    try_silent_print_with_exit \
      "geli init -g -J \"${temp_enc_passwd_file}\" ${zfs_part_path}" \
      "initializing encrypted GELI device on new zfs partition" 20

    try_silent_print_with_exit \
      "geli attach -j \"${temp_enc_passwd_file}\" ${zfs_part_path}" \
      "attaching encrypted GELI device to system" 20

    try_silent_with_exit \
      "rm \"${temp_enc_passwd_file}\"" \
      "error removing encryption password temp file" 20
  fi
}

attach_new_device_to_existing_zfs_device_in_mirror() {
  new_device_path="${1}"
  existing_zfs_device_path="${2}"
  pool="${3}"

  printf "NOTE: the following attach operation waits for the new zfs device to resilver, "
  printf "and can take 10 - 30 minutes, depending on disk size.\n"
  try_silent_print_with_exit \
    "zpool attach -w ${pool} \"${existing_zfs_device_path}\" \"${new_device_path}\"" \
    "attaching new device to existing zfs device, to create or extend the mirror," 60
}

attach_new_zfs_part_to_existing_mirror_part() {
  new_whole_disk_path="${1}"
  existing_zfs_part_device_path="${2}"
  pool="${3}"

  if [ "${ENCRYPTION_PASSWORD}" = '' ]; then
    new_zfs_part_path="$(print_path_to_zfs_partition_without_eli_ext "${new_whole_disk_path}")"
  else
    new_zfs_part_path="$(print_path_to_zfs_geli_ecrypted_partition "${new_whole_disk_path}")"
  fi

  attach_new_device_to_existing_zfs_device_in_mirror \
    "${new_zfs_part_path}" \
    "${existing_zfs_part_device_path}" \
    "${pool}"
}

do_print_help_menu() {
  print_usage
}

do_list_pools_status() {
  pools_status="$(zpool list -L -P -v)"
  quit_if_rc_not_zero "${?}" "error getting zpool status" 5
  printf "*********** STATUS OF ALL POOLS, ALONG WITH THEIR VDEVS AND DEVICES ************\n"
  printf "%s\n" "${pools_status}"
  printf "NOTE:\n"
  printf "Device names will change on boot, to maintain continuous 0, 1, n device numbering.\n"

  pools_health="$(zpool get -H -o value health)"
  quit_if_rc_not_zero "${?}" "error getting zpool health" 5
  printf "%s\n" "${pools_health}" | while IFS="$(printf "\n.")" read -r line; do
    if [ "${line}" != 'ONLINE' ]; then
      quit_with_err_msg "one or more devices in a pool's vdev is not online" 1
    fi
  done
}

do_create_storage_pool() {
  check_running_as_root
  check_whole_disk_option
  check_pool_is_not_root_pool "${POOL}"

  wipe_new_disk_as_required "${WHOLE_DISK_PATH}"

  mount_point="$(print_mount_point "${DEFAULT_MOUNT_POINT_BASE}" "${MOUNT_POINT}" "${POOL}")"
  try_silent_print_with_exit \
    "zpool create -f -m \"${mount_point}\"  ${POOL} \"${WHOLE_DISK_PATH}\"" \
    "creating new storage pool from single disk \"${WHOLE_DISK_PATH}\", mounted at \"${mount_point}\"," 80
}

do_detach_device_from_pool() {
  check_running_as_root
  check_active_zfs_device_option

  do_offline_device_from_pool

  try_silent_print_with_exit \
    "zpool detach ${POOL} ${ZFS_DEVICE_PATH}" \
    "detaching zfs device from pool" 10
}

do_attach_new_disk_to_root_mirror() {
  check_running_as_root
  check_zfs_part_device_option
  check_whole_disk_option
  check_encrypt_pswd_option_supplied_if_req
  check_pool_is_root_pool "${POOL}"

  wipe_new_disk_as_required "${WHOLE_DISK_PATH}"
  format_partitions_on_new_root_mirror_disk "${WHOLE_DISK_PATH}" "${ZFS_PART_DEVICE_PATH}"
  set_bootcode_on_new_root_mirror_disk "${WHOLE_DISK_PATH}"
  geli_encrypt_new_disk_zfs_part_as_req "${WHOLE_DISK_PATH}"
  attach_new_zfs_part_to_existing_mirror_part "${WHOLE_DISK_PATH}" "${ZFS_PART_DEVICE_PATH}" "${POOL}"
}

do_attach_new_disk_to_storage_mirror() {
  check_running_as_root
  check_zfs_disk_device_option
  check_whole_disk_option
  check_encrypt_pswd_option_is_not_specified
  check_pool_is_not_root_pool "${POOL}"

  wipe_new_disk_as_required "${WHOLE_DISK_PATH}"
  attach_new_device_to_existing_zfs_device_in_mirror \
    "${WHOLE_DISK_PATH}" \
    "${ZFS_DISK_DEVICE_PATH}" \
    "${POOL}"
}

do_add_read_cache_disk_to_pool() {
  check_running_as_root
  check_whole_disk_option

  wipe_new_disk_as_required "${WHOLE_DISK_PATH}"
  try_silent_print_with_exit \
    "zpool add ${POOL} cache \"${WHOLE_DISK_PATH}\"" \
    "adding read cache disk \"${WHOLE_DISK_PATH}\" to pool \"${POOL}\"" 60
}

do_scrub_pool_data() {
  check_running_as_root

  try_silent_print_with_exit \
    "zpool scrub -w ${POOL}" \
    "scrubbing and repairing all data in pool" 100
}

do_attach_zfs_part_to_root_mirror() {
  check_running_as_root
  check_zfs_part_device_option
  check_zfs_part_option
  check_pool_is_root_pool "${POOL}"

  attach_new_device_to_existing_zfs_device_in_mirror \
    "${ZFS_PART_PATH}" \
    "${ZFS_PART_DEVICE_PATH}" \
    "${POOL}"
}

do_offline_device_from_pool() {
  check_running_as_root
  check_active_zfs_device_option

  try_silent_print_with_exit \
    "zpool offline ${POOL} ${ZFS_DEVICE_PATH}" \
    "offlining zfs device" 10
}

do_online_device_into_pool() {
  check_running_as_root
  check_active_zfs_device_option

  try_silent_print_with_exit \
    "zpool online ${POOL} ${ZFS_DEVICE_PATH}" \
    "onlining zfs device" 60
}

# MAIN SCRIPT:

main() {
  get_cmd_opts "$@"

  if [ "${PRINT_HELP_MENU}" = 'true' ]; then
    do_print_help_menu
  elif [ "${LIST_POOLS_STATUS}" = 'true' ]; then
    do_list_pools_status
  elif [ "${CREATE_STORAGE_POOL}" = 'true' ]; then
    do_create_storage_pool
  elif [ "${DETACH_DEVICE_FROM_POOL}" = 'true' ]; then
    do_detach_device_from_pool
  elif [ "${ATTACH_NEW_DISK_TO_ROOT_MIRROR}" = 'true' ]; then
    do_attach_new_disk_to_root_mirror
  elif [ "${ATTACH_NEW_DISK_TO_STORAGE_MIRROR}" = 'true' ]; then
    do_attach_new_disk_to_storage_mirror
  elif [ "${ADD_READ_CACHE_DISK_TO_POOL}" = 'true' ]; then
    do_add_read_cache_disk_to_pool
  elif [ "${SCRUB_POOL_DATA}" = 'true' ]; then
    do_scrub_pool_data
  elif [ "${ATTACH_ZFS_PART_TO_ROOT_MIRROR}" = 'true' ]; then
    do_attach_zfs_part_to_root_mirror
  elif [ "${OFFLINE_DEVICE_FROM_POOL}" = 'true' ]; then
    do_offline_device_from_pool
  elif [ "${ONLINE_DEVICE_INTO_POOL}" = 'true' ]; then
    do_online_device_into_pool
  else
    quit_with_err_msg "no valid option selected" 5
  fi

  exit_with_cleanup 0
}

main "$@"

